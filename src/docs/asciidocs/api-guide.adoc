= HTTP Validator - Usage guide & API reference
by Asta86
:doctype: book
:icons: font
:source-highlighter: highlightjs
:highlightjs-theme: github
:toc: left
:toclevels: 3
:sectlinks:
:sectnums:


== Introduction

This project aims to ensure the reliability and consistency of a web application or HTTP-accessible resource by performing
automated checks on various web endpoints. It does this by periodically sending requests to these endpoints and validating
the responses based on predefined criteria.

=== Purpose

Automate the monitoring and validation of web application endpoints to quickly detect and respond to any issues.
This can help maintain the integrity and performance of the web application, ensuring that it functions correctly and meets expected standards.

=== Features

1. **Automated Validation Tasks**:
   - The system periodically sends HTTP requests to specified web endpoints.
   - It checks the responses against predefined criteria to ensure they are correct and expected.

2. **Configurable Task Management**:
   - Validation tasks are defined in an XML file, which can be updated independently of the application code.
   - This file can be modified either manually or through a web API, without needing to restart the application.

3. **Notification System**:
   - If any validation task detects an issue, the system sends an email notification.
   - This ensures that responsible parties are alerted promptly to any problems.

4. **Scheduling Flexibility**:
   - The schedule for running validation tasks can be set through the API or a separate configuration file.

=== Summary

In essence, the HTTP Validator can provide a robust yet flexible solution for monitoring web application endpoints and content or systems reachable via HTTP.
By automating the process of sending requests and validating responses, it helps ensure the application remains reliable and performant.

The ability to configure tasks and schedules easily, combined with prompt email notifications for issues and low resource usage, make it a practical tool
for monitoring and maintaining application health.


== Constructing an XML File for Validation Tasks

An XML file for defining validation tasks, which is used to specify the details of the tasks that the system will perform, follows a structured format.

=== Steps to create the XML file

1. **Start with the Root Element**: Begin your XML file with a root element called `validations`. This will contain all your individual validation tasks.

2. **Add Validation Elements**: Inside the `validations` element, you will add multiple `validation` elements. Each `validation` element represents a single task.

3. **Specify Attributes for Each Task**: For each `validation` element, you need to specify several attributes:
   - `reqmethod`: The HTTP request method (use `0` for `GET` requests).
   - `requrl`: The URL to which the request will be sent (up to 2000 characters).
   - `reqheaders`: Any headers that should be included in the request. These should be formatted as `HeaderName|HeaderValue`,
   separated by carets (`^`) if there are multiple headers (up to 4000 characters). Can be left empty for no headers.
   - `ressc`: The expected HTTP status code in the response.
   - `resbody`: The expected body of the response (up to 1000 characters).

=== Example XML Tasks

Below are some examples of validation tasks in XML format:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<validations>
    <!-- Example Task 1 -->
    <validation
        reqmethod="0"
        requrl="http://example.com/api/status"
        reqheaders="Authorization|Bearer token4534354X.9+yjo^Accept|application/json"
        ressc="200"
        resbody="A string in a plaintext response" />

    <!-- Example Task 2 -->
    <validation
        reqmethod="0"
        requrl="http://example.com/api/data"
        reqheaders="Accept|application/json"
        ressc="200"
        resbody="&quot;data&quot;:&quot;some JSON data&quot;" />

    <!-- Example Task 3 -->
    <validation
        reqmethod="0"
        requrl="http://example.com/api/health"
        reqheaders=""
        ressc="200"
        resbody='"health":87876854354' />

    <!-- Example Task 4 -->
    <validation
        reqmethod="0"
        requrl="http://example.com/api/info"
        reqheaders="Custom-Header|Header Value"
        ressc="404"
        resbody="" />
</validations>
```

=== Explanation of Examples

* **Example Task 1**:
  - **Request Method**: `GET` (indicated by `reqmethod="0"`)
  - **Request URL**: `http://example.com/api/status`
  - **Request Headers**: Two headers: `Authorization` with a bearer token and `Accept` with value `application/json`, separated by `^` (caret character)
  - **Expected Status Code**: `200`
  - **Expected Response Body**: The string expected to be present in a plaintext response

* **Example Task 2**:
  - **Request Method**: `GET`
  - **Request URL**: `http://example.com/api/data`
  - **Request Headers**: One header: `Accept` with value `application/json`
  - **Expected Status Code**: `200`
  - **Expected Response Body**: `"data":"some JSON data"`
  **Note:**

```xml
&quot; <!-- Is the escape character code used for quotation marks -->
```

* **Example Task 3**:
  - **Request Method**: `GET`
  - **Request URL**: `http://example.com/api/health`
  - **Request Headers**: No headers (indicated by empty value `""`)
  - **Expected Status Code**: `200`
  - **Expected Response Body**: `"health":87876854354`

**Note:** `'` is used to open and close the value of the attribute, allowing `"` to be used within it.

* **Example Task 4**:
  - **Request Method**: `GET`
  - **Request URL**: `http://example.com/oldpath`
  - **Request Headers**: One header: `Custom-Header` with value `Header Value`, separated by `|` (pipe character).
  Header values can contain unescaped spaces.
  - **Expected Status Code**: `404`
  - **Expected Response Body**: Body contents are ignored (indicated by empty value `""`)

Besides these common cases most text editors and many online tools can read an input URL or string and highlight any conflicting
characters in XML and provide alternatives to escape them.

By following this structure, you can easily define multiple validation tasks in an XML file, which the system will use to
perform automated checks on your web application endpoints.


== Running the application

=== Compiling the executable jar file

```bash
git clone https://github.com/lfir/http-validator.git
cd http-validator
./mvnw package
```

=== Starting the application

```bash
java -jar target/http-validator-x.y.z.jar
```

**NOTE:** If more than one version of Java is installed on the host a suitable one (**v17+**) might need to be specified
instead of the default before running the commands above, i.e.

```bash
export JAVA_HOME=/usr/lib/jvm/java-21-openjdk
./mvnw...
/path/to/java -jar...
```


== API - Information endpoints

=== Application Status

This endpoint provides the status of the web application, including start time, data file status, and configuration status.

==== Request Structure

include::{snippets}/can-get-app-status/http-request.adoc[]

==== Request Headers

include::{snippets}/can-get-app-status/request-headers.adoc[]

==== Response Structure

include::{snippets}/can-get-app-status/response-fields.adoc[]

==== Sample Response

include::{snippets}/can-get-app-status/http-response.adoc[]

==== CURL request

include::{snippets}/can-get-app-status/curl-request.adoc[]


=== Validation Tasks - Last Run data

This endpoint provides summary information about results of the last run of the validation tasks, including start time,
time elapsed, total tasks, tasks ok, tasks failed, and if errors occurred.

==== Request Structure

include::{snippets}/error503-when-no-last-run-data-available/http-request.adoc[]

==== Request Headers

include::{snippets}/error503-when-no-last-run-data-available/request-headers.adoc[]

==== Response Structure

The following fields will be included if data is available (at least one run of validations has already
completed) when the endpoint is called:

include::{snippets}/can-get-last-run-info-when-data-available/response-fields.adoc[]

If there's no data yet an error response like the one below will be returned.

include::{snippets}/error503-when-no-last-run-data-available/response-fields.adoc[]

==== Sample Response

include::{snippets}/error503-when-no-last-run-data-available/http-response.adoc[]

include::{snippets}/can-get-last-run-info-when-data-available/http-response.adoc[]

==== CURL request

include::{snippets}/error503-when-no-last-run-data-available/curl-request.adoc[]


== API - Configuration management endpoints

=== Update Validation Task definitions file

This endpoint updates the validator's data file with new validation tasks. The file should be an XML file that adheres
to the predefined https://github.com/lfir/http-validator/blob/main/src/main/resources/validations.xsd[schema^].

==== Request Structure

include::{snippets}/can-update-data-file-with-valid-xml/http-request.adoc[]

==== Request Headers

include::{snippets}/can-update-data-file-with-valid-xml/request-headers.adoc[]

==== Response Structure

If the new XML provided is valid according to the schema the body will be empty. Otherwise, an error message will be returned
indicating whether the problem was in the contents of the new file or the operation of writing it to disk.

include::{snippets}/error400-when-update-data-file-request-with-invalid-xml/response-fields.adoc[]

==== Sample Response

include::{snippets}/error400-when-update-data-file-request-with-invalid-xml/http-response.adoc[]

include::{snippets}/can-update-data-file-with-valid-xml/http-response.adoc[]

==== CURL request

include::{snippets}/can-update-data-file-with-valid-xml/curl-request.adoc[]


=== Update Run Schedule

This endpoint updates the validator's run schedule with a new
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html#cron()[cron expression^].

==== Request Structure

include::{snippets}/error400-when-update-run-schedule-request-with-invalid-cron-expression/http-request.adoc[]

==== Request Headers

include::{snippets}/error400-when-update-run-schedule-request-with-invalid-cron-expression/request-headers.adoc[]

==== Response Structure

If the new cron expression provided is valid the body will be empty. Otherwise, an error message will be returned.

include::{snippets}/error400-when-update-run-schedule-request-with-invalid-cron-expression/response-fields.adoc[]

==== Sample Response

include::{snippets}/error400-when-update-run-schedule-request-with-invalid-cron-expression/http-response.adoc[]

include::{snippets}/can-update-data-file-with-valid-xml/http-response.adoc[]

==== CURL request

include::{snippets}/error400-when-update-run-schedule-request-with-invalid-cron-expression/curl-request.adoc[]


== Important files used by the application

- **./config/application.properties** - Used to set the run schedule and location of the datafile.
Restarting the application manually after a change to this file is required so they enter in effect.
- **./config/validations.xml** - File with the validation task definitions.
- **./logs/spring-framework.log** - The main log file of the application.


== Limitations and other relevant information

- At this stage of the project Validation Tasks can only send `GET` requests and validate responses with empty body or
discrete, text-only data like plaintext, CSV, HTML, JSON, etc.
- When the run schedule is updated from the API WebApplicationContext is restarted automatically to begin
using it (PID remains the same, beans & variables like `start_time` are re-initialized).
